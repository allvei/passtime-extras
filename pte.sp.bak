#include <sdktools_functions>
#include <sourcemod>
#include <tf2>
#include <tf2_stocks>
#include <clientprefs>
#include <clients>
#include <sdktools>
#include <sdktools_gamerules>
#include <sdktools_trace>
#include <sdktools_entoutput>
#include <sdkhooks>

#pragma semicolon 1

// Constants
#define RED         0
#define BLU         1
#define TEAM_OFFSET 2

// MACROS
#define PCH return Plugin_Changed
#define PCO return Plugin_Continue
#define PH  return Plugin_Handled
#define pub public
#define Act Action
#define Han Handle
#define Ev  Event
#define i   int
#define v   void
#define f   float
#define b   bool
#define c   char
#define RCC RegConsoleCmd
#define RAC RegAdminCmd
#define HE  HookEvent
#define NEW_CMD(%1) pub Act %1( i client, i args )
#define NEW_EV_ACT(%1) pub Act %1( Ev event, const c[] name, b dontBroadcast )
#define NEW_EV(%1) pub %1( Ev event, const c[] name, b dontBroadcast )

public Plugin myinfo = {
    name        = "passtime.tf extras",
    author      = "xCape",
    description = "Plugin for use in passtime.tf servers",
    version     = "1.5",
    url         = "https://github.com/allvei"
}

// Handles
Han g_hCookieFOV;
Han g_hCookieInfiniteAmmo;
Han g_hCookieImmunity;
Han g_cvFOVMin;
Han g_cvFOVMax;

// Backup system for FOV tracking when Steam connection is down
b g_bSteamConnected = true;           // Track if Steam is currently connected
b g_bBackupFOVDB    = false;          // Track if we're using the backup system
b g_bPlayerTracked[ MAXPLAYERS + 1 ]; // Track if we have a FOV value for this player
i g_iPlayerFOV[     MAXPLAYERS + 1 ]; // Store FOV values for each player

// Backup system for infinite ammo and immunity when Steam is down
b g_bBackupInfiniteAmmoTracked[MAXPLAYERS + 1]; // Track if we have infinite ammo setting for this player
b g_bBackupImmunityTracked[MAXPLAYERS + 1];     // Track if we have immunity setting for this player
b g_bBackupInfiniteAmmo[MAXPLAYERS + 1];        // Store infinite ammo setting for each player
b g_bBackupImmunity[MAXPLAYERS + 1];            // Store immunity setting for each player

// Spawn room tracking
b g_bIsClientInSpawn[MAXPLAYERS + 1];               // Track if player is in any spawn room
#define MAX_SPAWN_ROOMS 8                           // Maximum number of spawn rooms a player can touch simultaneously
i g_iPlayerSpawns[MAXPLAYERS + 1][MAX_SPAWN_ROOMS]; // Track which spawn rooms a player is in
i g_iSpawnTeam[2048];                               // Track which team a spawn room belongs to (entity index -> team)
b g_bResupplyDn[MAXPLAYERS + 1];                    // Track if resupply key is currently down
b g_bResupplyUp[MAXPLAYERS + 1];                    // Track if resupply has been used during current key press

// No-damage toggle per player
b g_bNoDamage[MAXPLAYERS + 1];
i g_iPreDamageHP[MAXPLAYERS + 1];
b g_bPendingRestoreHP[MAXPLAYERS + 1];

// Infinite ammo toggle per player
b g_bInfiniteAmmo[MAXPLAYERS + 1];

// Original ammo values for infinite ammo restoration (only allocated for players using infinite ammo)
ArrayList g_hOriginalAmmo[MAXPLAYERS + 1]; // Dynamic arrays for players who actually use infinite ammo

// Respawn time control
ConVar g_cvRespawnTime;
b g_bTeamReadyState[2] = { false, false }; // Track ready state for RED and BLU

// Saved spawn point (admin tools)
b g_bSavedSpawnValid = false;
f g_vSavedSpawnOrigin[3];
f g_vSavedSpawnAngles[3];
f g_vSavedSpawnVelocity[3];

// Emergency tournament controls
b g_bResupplyEnabled = true;       // Global toggle for resupply functionality
b g_bInstantRespawnEnabled = true; // Global toggle for instant respawn
b g_bImmunityAmmoEnabled = true;   // Global toggle for immunity and infinite ammo
b g_bSaveLoadEnabled = true;       // Global toggle for save/load spawn functionality

// Stalemate fix variables
b g_bFixStalemateScoring = true;   // Global toggle for stalemate scoring fix
b g_bDisableOvertime = false;      // Global toggle to disable overtime entirely
b g_bScoredIntoStalemate = false; // Track if we just scored into stalemate
b g_bInOvertime = false;           // Track if we're currently in overtime
b g_bMonitorBallState = false;     // Track if we should monitor ball state in OnGameFrame
f g_fBallNeutralStartTime = 0.0;   // Track when ball went neutral
i g_iLastBallTeam = -1;            // Track last known ball team to detect changes


// Resupply failsafe system
#define FAILSAFE_DISTANCE 512.0 // Maximum distance from spawn point in Hammer units
b g_bFailsafeTriggered = false; // Track if failsafe has been triggered

#define MAX_SLOTS 6
i g_iSavedClip1[MAX_SLOTS];
i g_iSavedClip2[MAX_SLOTS];
i g_iSavedAmmoType[MAX_SLOTS][2];
i g_iSavedAmmoCount[MAX_SLOTS][2];

pub OnPluginStart() {
    // Register admin commands
    RAC( "sm_setteam",         CSetTeam,        ADMFLAG_GENERIC, "Set a client's team" );
    RAC( "sm_st",              CSetTeam,        ADMFLAG_GENERIC, "Set a client's team" );
    RAC( "sm_setclass",        CSetClass,       ADMFLAG_GENERIC, "Set a client's class" );
    RAC( "sm_sc",              CSetClass,       ADMFLAG_GENERIC, "Set a client's class" );
    RAC( "sm_ready",           CReady,          ADMFLAG_GENERIC, "Set a team's ready status" );
    RAC( "sm_rdy",             CReady,          ADMFLAG_GENERIC, "Set a team's ready status" );
    RAC( "sm_debug_roundtime", CRoundTimeDebug, ADMFLAG_GENERIC, "Debug: print team_round_timer info" );
    RAC( "sm_drt",             CRoundTimeDebug, ADMFLAG_GENERIC, "Debug: print team_round_timer info" );
    
    // Emergency tournament admin commands
    RAC( "sm_enable_resupply", CToggleResupply, ADMFLAG_ROOT, "Emergency: Toggle resupply functionality" );
    RAC( "sm_enable_respawn",  CToggleRespawn,  ADMFLAG_ROOT, "Emergency: Toggle instant respawn" );
    RAC( "sm_enable_immunity", CToggleImmunity, ADMFLAG_ROOT, "Emergency: Toggle immunity and infinite ammo" );
    RAC( "sm_enable_saveload", CToggleSaveLoad, ADMFLAG_ROOT, "Emergency: Toggle save/load spawn functionality" );
    RAC( "sm_plugin_status",   CPluginStatus,   ADMFLAG_ROOT, "Show current plugin feature status" );
    RAC( "sm_stalemate_fix",   CStalemateFix,   ADMFLAG_ROOT, "Toggle stalemate scoring fix" );
    RAC( "sm_disable_overtime", CDisableOvertime, ADMFLAG_ROOT, "Toggle overtime disable" );

    // Register console commands
    RCC( "sm_save",         CSaveSpawn,    "Save a spawn point" );
    RCC( "sm_sv",           CSaveSpawn,    "Save a spawn point" );
    RCC( "sm_load",         CLoadSpawn,    "Teleport to saved spawn" );
    RCC( "sm_ld",           CLoadSpawn,    "Teleport to saved spawn" );
    RCC( "sm_immune",       CImmune,       "Toggle immunity" );
    RCC( "sm_i",            CImmune,       "Toggle immunity" );
    RCC( "sm_ammo",         CInfiniteAmmo, "Toggle infinite ammo" );
    RCC( "sm_a",            CInfiniteAmmo, "Toggle infinite ammo" );
    RCC( "sm_fov",          CSetFOV,       "Set your field of view." );
    RCC( "+sm_resupply",    CResupplyDn,   "Resupply inside spawn" );
    RCC( "-sm_resupply",    CResupplyUp,   "Resupply inside spawn" );
    RCC( "+sm_pt_resupply", CResupplyDn,   "Resupply inside spawn" );
    RCC( "-sm_pt_resupply", CResupplyUp,   "Resupply inside spawn" );

    g_hCookieFOV = RegClientCookie( "sm_fov_cookie", "Desired client field of view", CookieAccess_Private );
    g_hCookieInfiniteAmmo = RegClientCookie( "sm_infiniteammo_cookie", "Infinite ammo setting", CookieAccess_Private );
    g_hCookieImmunity     = RegClientCookie( "sm_immunity_cookie", "Immunity setting", CookieAccess_Private );

    g_cvFOVMin      = CreateConVar( "sm_fov_min",      "70",  "Minimum client field of view", _, 1, 1.0, 1, 175.0 );
    g_cvFOVMax      = CreateConVar( "sm_fov_max",      "120", "Maximum client field of view", _, 1, 1.0, 1, 175.0 );
    g_cvRespawnTime = CreateConVar( "sm_respawn_time", "0.0", "Player respawn delay in seconds", FCVAR_NOTIFY );

    // Hook events
    HE( "player_spawn",      EPSpawn );
    HE( "player_connect",    EPConnect );
    HE( "player_disconnect", EPDisconnect );
    HE( "player_death",      EPDeath );
    
    // Hook PASS Time events for stalemate fix
    HE( "pass_score",             EPPassScore );
    HE( "pass_free",              EPPassFree );
    HE( "pass_get",               EPPassGet );
    HE( "teamplay_round_stalemate", EPStalemate );
    HE( "teamplay_overtime_begin",  EPOvertimeBegin );
    HE( "teamplay_overtime_end",    EPOvertimeEnd );
    
    // Initialize team ready states
    g_bTeamReadyState[0] = false;
    g_bTeamReadyState[1] = false;
    
    // Spawn room entity outputs are now handled by direct collision detection
    // No need to hook OnStartTouch/OnEndTouch as we use IsPlayerTouchingSpawn()
    
    // Initialize spawn room tracking arrays
    for (i n = 1; n <= MaxClients; n++) {
        g_bIsClientInSpawn[n] = false;
        g_bResupplyDn[n]      = false;
        g_bResupplyUp[n]      = false;
        
        // Initialize spawn room entity tracking
        for (i s = 0; s < MAX_SPAWN_ROOMS; s++) {
            g_iPlayerSpawns[n][s] = -1;  // -1 means no entity
        }
    }
    
    // Initialize spawn room team tracking
    for (i n = 0; n < 2048; n++) {
        g_iSpawnTeam[n] = 0;  // 0 means unassigned team
    }
    
    // Initialize saved ammo/velocity buffers
    for (i s = 0; s < MAX_SLOTS; s++) {
        g_iSavedClip1[s] = -1;
        g_iSavedClip2[s] = -1;
        for (i t = 0; t < 2; t++) {
            g_iSavedAmmoType[s][t]  = -1;
            g_iSavedAmmoCount[s][t] = 0;
        }
    }
    
    // Initialize infinite ammo ArrayList handles and backup tracking
    for (i n = 1; n <= MaxClients; n++) {
        g_hOriginalAmmo[n] = null;
        g_bInfiniteAmmo[n] = false;
        g_bBackupInfiniteAmmoTracked[n] = false;
        g_bBackupImmunityTracked[n] = false;
        g_bBackupInfiniteAmmo[n] = false;
        g_bBackupImmunity[n] = false;
    }
    
    // Hook damage for currently connected clients and reset nodamage flags
    for (i n = 1; n <= MaxClients; n++) {
        g_bNoDamage[n] = false;
        g_bPendingRestoreHP[n] = false;
        g_iPreDamageHP[n] = 0;
        if ( IsClientInGame(n) ) {
            SDKHook( n, SDKHook_OnTakeDamage,     Hook_OnTakeDamage );
            SDKHook( n, SDKHook_OnTakeDamagePost, Hook_OnTakeDamagePost );
        }
    }
}

// OnGameFrame - replenish ammo every frame for infinite ammo players and check for buffered resupply
pub v OnGameFrame() {
    
    // Loop through all clients
    for ( i client = 1; client <= MaxClients; client++ ) {
        // Check if client is valid and in-game
        if (IsClientInGame(client) && client <= MaxClients) {
            // Check for infinite ammo players (excluding medics) and if globally enabled
            if ( IsValidClient( client ) && g_bInfiniteAmmo[ client ] && g_bImmunityAmmoEnabled && !IsMatchActive()) {
                // Ignore medics with infinite ammo
                if (TF2_GetPlayerClass(client) == TFClass_Medic) continue;
                
                // Get the active weapon
                i weapon = GetEntPropEnt( client, Prop_Send, "m_hActiveWeapon" );
                if ( weapon == -1 || !IsValidEntity( weapon ) ) continue;
                
                // Replenish clip ammo to a high value (99)
                SetEntProp( weapon, Prop_Send, "m_iClip1", 99 );
                SetEntProp( weapon, Prop_Send, "m_iClip2", 99 );
                
                // Replenish reserve ammo for all ammo types
                // TF2 has a maximum of 32 ammo types
                for ( i ammoType = 0; ammoType < 32; ammoType++ ) {
                    SetEntProp( client, Prop_Send, "m_iAmmo", 999, _, ammoType );
                }
            }
            
            // Check for buffered resupply (only if globally enabled)
            if (g_bResupplyEnabled && g_bResupplyDn[client] && !g_bResupplyUp[client]) {
                // Check if player has entered a spawn room
                if (IsClientInSpawn(client)) {
                    // Resupply the player
                    TryResupplyPlayer(client);
                }
            }
        }
    }
    
    // Monitor ball state for stalemate fix (during tied overtime or when timer finished)
    if (g_bMonitorBallState && g_bFixStalemateScoring) {
        CheckBallNeutralState();
    }
}

// Hook per-client when they enter the server so our damage filter is active
pub v OnClientPutInServer( i client ) {
    SDKHook( client, SDKHook_OnTakeDamage,     Hook_OnTakeDamage );
    SDKHook( client, SDKHook_OnTakeDamagePost, Hook_OnTakeDamagePost );
}


b IsMatchActive() {
    // Match is not active if game is awaiting ready restart, timer is paused, or timer is disabled
    b awaitingReadyRestart = view_as<b>(GameRules_GetProp("m_bAwaitingReadyRestart"));
    
    i timerEnt = -1;
    b timerPaused = false;
    b timerDisabled = false;
    b IsPostRound = GameRules_GetRoundState() == RoundState_TeamWin;
    
    // Find any active team_round_timer entity
    while ((timerEnt = FindEntityByClassname(timerEnt, "team_round_timer")) != -1) {
        timerPaused   = view_as<b>(GetEntProp(timerEnt, Prop_Send, "m_bTimerPaused"));
        timerDisabled = view_as<b>(GetEntProp(timerEnt, Prop_Send, "m_bIsDisabled"));
        
        // If we found a timer, break since we only need to check one
        if (timerEnt != -1) break;
    }
    
    // Match is active only if we're not awaiting ready restart and timer is running (not paused and not disabled)
    return !(awaitingReadyRestart || timerPaused || timerDisabled || IsPostRound);
}

// ====================================================================================================
// COMMANDS
// ====================================================================================================

// Command to manually set a team's ready status
NEW_CMD(CReady) {
    if (IsMatchActive()) PCO;
    
    if ( args != 2 ) return EndCmd( client, "Usage: sm_ready <red|blu> <0|1>" );

    c teamArg[ 10 ];
    c statusArg[ 2 ];

    GetCmdArg( 1, teamArg,   sizeof( teamArg ) );
    GetCmdArg( 2, statusArg, sizeof( statusArg ) );

    i teamIndex = ParseTeamIndex( teamArg );
    i status    = StringToInt( statusArg );

    // Validate input
    if ( teamIndex == -1 ) return EndCmd( client, "Invalid team. Use 'red|r', 'blue|blu|b'." );
    if ( status < 0 || status > 1 ) return EndCmd( client, "Invalid status. Use 0 (not ready) or 1 (ready)." );

    // Set the team's ready status
    i gameRulesTeamOffset = teamIndex + TEAM_OFFSET;
    GameRules_SetProp( "m_bTeamReady", status, 1, gameRulesTeamOffset );
    
    // Update our internal tracking
    g_bTeamReadyState[teamIndex] = (status != 0);
    
    PH;
}

// Delayed reply functions for Monty Python style messages
pub v DelayedReply1(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01But not because we think you're a bad person or anything.");
        CreateTimer(4.0, DelayedReply2, client);
    }
}

pub v DelayedReply2(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01It's just that this command is what we in the business call \"a bit naughty\"");
        CreateTimer(4.0, DelayedReply3, client);
    }
}

pub v DelayedReply3(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01- not in the sense of being morally wrong,");
        CreateTimer(3.0, DelayedReply4, client);
    }
}

pub v DelayedReply4(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01but rather in the technical sense that it disrupts the delicate balance of player enjoyment in our fine establishment.");
        CreateTimer(5.0, DelayedReply5, client);
    }
}

pub v DelayedReply5(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01This feature has been temporarily disabled to prevent what we like to call \"accidental player disruption syndrome\".");
        CreateTimer(5.0, DelayedReply6, client);
    }
}

pub v DelayedReply6(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01A condition that affects well-meaning administrators who, in their quest for efficiency, sometimes overlook the social implications of their actions.");
        CreateTimer(6.0, DelayedReply7, client);
    }
}

pub v DelayedReply7(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01It's nothing to be ashamed of, really.");
        PrintToChat(client, "\x04[ADMIN] \x01Many fine admins have suffered from this condition.");
        CreateTimer(3.0, DelayedReply8, client);
    }
}

pub v DelayedReply8(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01This feature has been temporarily disabled to prevent what we like to call \"accidental player disruption syndrome\".");
        PrintToChat(client, "\x04[ADMIN] \x01A condition that affects well-meaning administrators who, in their quest for efficiency, sometimes overlook the social implications of their actions.");
        CreateTimer(8.0, DelayedReply9, client);
    }
}

pub v DelayedReply9(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01It's nothing to be ashamed of, really.");
        PrintToChat(client, "\x04[ADMIN] \x01Many fine admins have suffered from this condition.");
        CreateTimer(3.0, DelayedReply10, client);
    }
}

pub v DelayedReply10(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01Many fine admins have suffered from this condition.");
        CreateTimer(3.0, DelayedReply11, client);
    }
}

pub v DelayedReply11(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01Many fine admins have suffered from this condition.");
        CreateTimer(3.0, DelayedReply12, client);
    }
}

pub v DelayedReply12(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01But enough dithering! What we're trying to say - and do get on with it - is that you should try a more targeted approach with specific players or different team assignments.");
        CreateTimer(6.0, DelayedReply13, client);
    }
}

pub v DelayedReply13(Han timer, any client) {
    if (IsValidClient(client)) {
        PrintToChat(client, "\x04[ADMIN] \x01It's much more sporting that way, and the players will appreciate not being dragged away from their carefully chosen teams like a knight being dragged away from his quest!");
    }
}

// Change client's team
NEW_CMD(CSetTeam) {
    // Parse team argument early so it's available in all code paths
    c target[33];
    GetCmdArg(1, target, sizeof(target));

    c input_team[5];
    GetCmdArg(2, input_team, sizeof(input_team));
    TFTeam team = ParseTeam(input_team);
    
    // If they're trying to set everyone to spectator, deny with a funny message
// if (StrEqual(target, "@all") && team == TFTeam_Spectator) {
//     PrintToChat(client, "\x04[ADMIN] \x01And now for something completely different! You see, your outrageous request to set everyone to spectator has been... how do you say... DENIED!");
//     CreateTimer(5.0, DelayedReply1, client);
// }
    
    if ( args != 2 || team == TFTeam_Unassigned ) return EndCmd( client, "Usage: sm_setteam <#userid|name> <spec|red|blu>", args );


    i target_list[ MAXPLAYERS ];
    c target_name[ MAX_TARGET_LENGTH ];
    b tn_is_ml     = false;
    i target_count = ProcessTargetString( target, client, target_list, MAXPLAYERS, COMMAND_FILTER_CONNECTED, target_name, sizeof( target_name ), tn_is_ml );
    b check        = false;

    if ( target_count == COMMAND_TARGET_NONE ) PH;

    // Change team of client(s)
    for ( i n = 0; n < target_count; n++ ) {
        i targetId = target_list[ n ];
        if ( !IsValidClient( targetId ) || TF2_GetClientTeam( targetId ) == team ) {
            continue;
        }
        check = true;
        ForcePlayerSuicide( targetId );
        TF2_ChangeClientTeam( targetId, team );
        if ( team != TFTeam_Spectator ) TF2_RespawnPlayer( targetId );
    }

    if ( check ) {
        for ( i n = 1; n <= MaxClients; n++ ) {
            GameRules_SetProp( "m_bTeamReady", 0, .element = n );
        }

        c team_name[ 5 ];
        GetTeamName( view_as<i>( team ), team_name, sizeof( team_name ) );

        ReplyToCommand( client, "Switched %s to %s", target_name, team_name );
    }
    PH;
}

// Set your field of view
NEW_CMD(CSetFOV) {
    if ( args != 1 ) return EndCmd( client, "Usage: sm_fov <fov>" );

    i fov = GetCmdArgInt( 1 ),
      min = GetConVarInt( g_cvFOVMin ),
      max = GetConVarInt( g_cvFOVMax );

    if ( fov == 0 ) {
        QueryClientConVar( client, "fov_desired", OnFOVQueried );
        return EndCmd( client, "Your FOV has been reset." );
    }

    if ( fov < min ) return EndCmd( client, "The minimum FOV you can set is %d.", min );
    if ( fov > max ) return EndCmd( client, "The maximum FOV you can set is %d.", max );

    // Try to store in cookies if available
    b cookieSuccess = false;
    if ( AreClientCookiesCached( client ) ) {
        c cookie[ 4 ];
        IntToString( fov, cookie, sizeof( cookie ) );
        SetClientCookie( client, g_hCookieFOV, cookie );
        cookieSuccess     = true;
        g_bSteamConnected = true;    // Steam is connected if cookies work

        // If we were using backup system but Steam is now connected, we can disable it
        if ( g_bBackupFOVDB ) SetBackupSystem( false );
    } else {
        // Steam is down, initialize backup system if not already done
        if ( !g_bBackupFOVDB ) SetBackupSystem( true );
        g_bSteamConnected = false;

        // Store in backup system
        g_iPlayerFOV[ client ]     = fov;
        g_bPlayerTracked[ client ] = true;
    }

    // Apply FOV immediately
    SetFOV( client, fov );

    ReplyToCommand( client, "Your FOV has been set to %d.%s", fov,
                    cookieSuccess ? "" : " (Steam connection down, saved for this session only)" );
    PH;
}

// Save a spawn point (global) - allowed only when round is inactive
NEW_CMD(CSaveSpawn) {
    if (!g_bSaveLoadEnabled) return EndCmd(client, "Save/Load spawn functionality has been disabled by an administrator.");
    if (IsMatchActive()) return EndCmd(client, "Saving spawn points is disabled in match mode.");

    if ( args != 0 ) return EndCmd( client, "Usage: sm_save" );
    if ( client <= 0 || client > MaxClients || !IsClientInGame( client ) ) PH;
    if ( !IsPlayerAlive( client ) ) return EndCmd( client, "You must be alive to save your position." );

    GetClientAbsOrigin( client, g_vSavedSpawnOrigin );
    GetClientEyeAngles( client,  g_vSavedSpawnAngles );
    // Save current velocity
    GetEntPropVector( client, Prop_Data, "m_vecAbsVelocity", g_vSavedSpawnVelocity );
    
    // Save current ammo and clips for carried weapons
    for ( i s = 0; s < MAX_SLOTS; s++ ) {
        g_iSavedClip1[s] = -1;
        g_iSavedClip2[s] = -1;
        g_iSavedAmmoType[s][0] = -1;
        g_iSavedAmmoType[s][1] = -1;
        g_iSavedAmmoCount[s][0] = 0;
        g_iSavedAmmoCount[s][1] = 0;
        
        i wep = GetPlayerWeaponSlot( client, s );
        if ( wep != -1 ) {
            g_iSavedClip1[s] = GetEntProp( wep, Prop_Send, "m_iClip1" );
            g_iSavedClip2[s] = GetEntProp( wep, Prop_Send, "m_iClip2" );
            
            i at1 = GetEntProp( wep, Prop_Send, "m_iPrimaryAmmoType" );
            i at2 = GetEntProp( wep, Prop_Send, "m_iSecondaryAmmoType" );
            g_iSavedAmmoType[s][0] = at1;
            g_iSavedAmmoType[s][1] = at2;
            if ( at1 >= 0 ) g_iSavedAmmoCount[s][0] = GetEntProp( client, Prop_Send, "m_iAmmo", _, at1 );
            if ( at2 >= 0 ) g_iSavedAmmoCount[s][1] = GetEntProp( client, Prop_Send, "m_iAmmo", _, at2 );
        }
    }
    g_bSavedSpawnValid = true;

    EndCmd( client, "Saved spawn at (%.1f %.1f %.1f)", g_vSavedSpawnOrigin[0], g_vSavedSpawnOrigin[1], g_vSavedSpawnOrigin[2] );
    
    PH;
}

// Load (teleport) to saved spawn - allowed only when round is inactive
NEW_CMD(CLoadSpawn) {
    if (!g_bSaveLoadEnabled) return EndCmd(client, "Save/Load spawn functionality has been disabled by an administrator.");
    if (IsMatchActive()) return EndCmd(client, "Loading spawn points is disabled in match mode.");

    if ( args != 0 ) return EndCmd( client, "Usage: sm_load" );
    if ( !g_bSavedSpawnValid ) return EndCmd( client, "No saved spawn point set yet." );
    if ( client <= 0 || client > MaxClients || !IsClientInGame( client ) ) PH;
    if ( !IsPlayerAlive( client ) ) return EndCmd( client, "You must be alive to use this." );

    TeleportEntity( client, g_vSavedSpawnOrigin, g_vSavedSpawnAngles, g_vSavedSpawnVelocity );
    
    // Restore ammo and clips for current carried weapons
    for ( i s = 0; s < MAX_SLOTS; s++ ) {
        i wep = GetPlayerWeaponSlot( client, s );
        if ( wep != -1 ) {
            if ( g_iSavedClip1[s] >= 0 ) SetEntProp( wep, Prop_Send, "m_iClip1", g_iSavedClip1[s] );
            if ( g_iSavedClip2[s] >= 0 ) SetEntProp( wep, Prop_Send, "m_iClip2", g_iSavedClip2[s] );
        }
        
        // Set reserve ammo by ammo types
        i at1 = g_iSavedAmmoType[s][0];
        i at2 = g_iSavedAmmoType[s][1];
        if ( at1 >= 0 ) SetEntProp( client, Prop_Send, "m_iAmmo", g_iSavedAmmoCount[s][0], _, at1 );
        if ( at2 >= 0 ) SetEntProp( client, Prop_Send, "m_iAmmo", g_iSavedAmmoCount[s][1], _, at2 );
    }
    PH;
}

// Toggle no-damage mode: you take no damage and deal no damage (knockback still applies)
NEW_CMD(CImmune) {
    if (!g_bImmunityAmmoEnabled) return EndCmd(client, "Immunity functionality has been disabled by an administrator.");
    if (IsMatchActive()) return EndCmd(client, "No-damage mode is disabled in match mode.");

    if ( args > 1 ) return EndCmd( client, "Usage: sm_nodamage [0|1]" );
    
    b newValue;
    
    if ( args == 0 ) {
        newValue = !g_bNoDamage[ client ];
        g_bNoDamage[ client ] = newValue;
    } else {
        c arg[ 12 ];
        GetCmdArg( 1, arg, sizeof( arg ) );
        if ( StrEqual( arg, "1" ) || StrEqual( arg, "on", false ) || StrEqual( arg, "true", false ) || StrEqual( arg, "enable", false ) ) {
            newValue = true;
            g_bNoDamage[ client ] = true;
        } else if ( StrEqual( arg, "0" ) || StrEqual( arg, "off", false ) || StrEqual( arg, "false", false ) || StrEqual( arg, "disable", false ) ) {
            newValue = false;
            g_bNoDamage[ client ] = false;
        } else {
            return EndCmd( client, "Usage: sm_nodamage [0|1]" );
        }
    }
    
    // Save immunity setting to cookies
    SaveImmunitySetting(client, g_bNoDamage[client]);
    
    // If player is alive, force respawn to apply changes cleanly
    if ( IsPlayerAlive( client ) ) {
        TF2_RespawnPlayer( client );
    }
    
    ReplyToCommand( client, "No-damage %s.", g_bNoDamage[ client ] ? "ENABLED" : "DISABLED" );
    PH;
}

// Toggle infinite ammo mode
NEW_CMD(CInfiniteAmmo) {
    if (!g_bImmunityAmmoEnabled) return EndCmd(client, "Infinite ammo functionality has been disabled by an administrator.");
    if (IsMatchActive()) return EndCmd(client, "Infinite ammo mode is disabled in match mode.");

    if ( args > 1 ) return EndCmd( client, "Usage: sm_infammo [0|1]" );
    
    b oldValue = g_bInfiniteAmmo[ client ];
    
    if ( args == 0 ) {
        g_bInfiniteAmmo[ client ] = !g_bInfiniteAmmo[ client ];
    } else {
        c arg[ 12 ];
        GetCmdArg( 1, arg, sizeof( arg ) );
        if ( StrEqual( arg, "1" ) || StrEqual( arg, "on", false ) || StrEqual( arg, "true", false ) || StrEqual( arg, "enable", false ) ) {
            g_bInfiniteAmmo[ client ] = true;
            
            // If enabling and wasn't previously enabled, store original ammo values
            if ( !oldValue ) {
                StoreOriginalAmmo( client );
            }
        } else if ( StrEqual( arg, "0" ) || StrEqual( arg, "off", false ) || StrEqual( arg, "false", false ) || StrEqual( arg, "disable", false ) ) {
            g_bInfiniteAmmo[ client ] = false;
        } else {
            return EndCmd( client, "Usage: sm_infammo [0|1]" );
        }
    }
    
    // Save infinite ammo setting to cookies
    SaveInfiniteAmmoSetting(client, g_bInfiniteAmmo[client]);
    
    // If player is alive, force respawn to apply changes cleanly
    if ( IsPlayerAlive( client ) ) {
        TF2_RespawnPlayer( client );
    }
    
    ReplyToCommand( client, "Infinite ammo %s.", g_bInfiniteAmmo[ client ] ? "ENABLED" : "DISABLED" );
    PH;
}

// Set a player's class
NEW_CMD(CSetClass) {
    if ( args != 2 ) return EndCmd( client, "Usage: sm_setclass <#userid|name> <class>" );

    c classArg[ 16 ];
    GetCmdArg( 2, classArg, sizeof( classArg ) );
    TFClassType tfclass = ParseClass( classArg );
    if ( tfclass == TFClass_Unknown ) return EndCmd( client, "Invalid class. Use class name or number" );

    c targetArg[ 33 ];
    GetCmdArg( 1, targetArg, sizeof( targetArg ) );

    i targets[ MAXPLAYERS ];
    c target_name[ MAX_TARGET_LENGTH ];
    b tn_is_ml = false;
    i count = ProcessTargetString( targetArg, client, targets, MAXPLAYERS, COMMAND_FILTER_CONNECTED, target_name, sizeof( target_name ), tn_is_ml );
    b changed = false;
    if ( count == COMMAND_TARGET_NONE ) PH;

    for ( i n = 0; n < count; n++ ) {
        i tid = targets[ n ];
        if ( tid <= 0 || tid > MaxClients || !IsClientInGame( tid ) ) continue;
        if ( TF2_GetClientTeam( tid ) == TFTeam_Spectator ) continue;
        TF2_SetPlayerClass( tid, tfclass );
        TF2_RespawnPlayer( tid );
        changed = true;
    }

    if ( changed ) {
        c className[16];
        switch (tfclass) {
            case TFClass_Scout:    strcopy(className, sizeof(className), "Scout");
            case TFClass_Soldier:  strcopy(className, sizeof(className), "Soldier");
            case TFClass_Pyro:     strcopy(className, sizeof(className), "Pyro");
            case TFClass_DemoMan:  strcopy(className, sizeof(className), "Demoman");
            case TFClass_Heavy:    strcopy(className, sizeof(className), "Heavy");
            case TFClass_Engineer: strcopy(className, sizeof(className), "Engineer");
            case TFClass_Medic:    strcopy(className, sizeof(className), "Medic");
            case TFClass_Sniper:   strcopy(className, sizeof(className), "Sniper");
            case TFClass_Spy:      strcopy(className, sizeof(className), "Spy");
            default:               strcopy(className, sizeof(className), "Unknown");
        }
        ReplyToCommand( client, "Set %s class to %s", target_name, className );
    }
    PH;
}

// Debug: print team_round_timer state
NEW_CMD(CRoundTimeDebug) {
    i ent = -1;
    i found = 0;
    
    while ((ent = FindEntityByClassname(ent, "team_round_timer")) != -1) {
        b timerPaused         = view_as<b>(GetEntProp(     ent, Prop_Send, "m_bTimerPaused"));
        f timeRemaining       =            GetEntPropFloat(ent, Prop_Send, "m_flTimeRemaining");
        f timerEndTime        =            GetEntPropFloat(ent, Prop_Send, "m_flTimerEndTime");
        b isDisabled          = view_as<b>(GetEntProp(     ent, Prop_Send, "m_bIsDisabled"));
        b showInHUD           = view_as<b>(GetEntProp(     ent, Prop_Send, "m_bShowInHUD"));
        i timerLength         =            GetEntProp(     ent, Prop_Send, "m_nTimerLength");
        i timerInitialLength  =            GetEntProp(     ent, Prop_Send, "m_nTimerInitialLength");
        i timerMaxLength      =            GetEntProp(     ent, Prop_Send, "m_nTimerMaxLength");
        b autoCountdown       = view_as<b>(GetEntProp(     ent, Prop_Send, "m_bAutoCountdown"));
        i setupTimeLength     =            GetEntProp(     ent, Prop_Send, "m_nSetupTimeLength");
        i state               =            GetEntProp(     ent, Prop_Send, "m_nState");
        b startPaused         = view_as<b>(GetEntProp(     ent, Prop_Send, "m_bStartPaused"));
        b showTimeRemaining   = view_as<b>(GetEntProp(     ent, Prop_Send, "m_bShowTimeRemaining"));
        b inCaptureWatchState = view_as<b>(GetEntProp(     ent, Prop_Send, "m_bInCaptureWatchState"));
        f totalTime           =            GetEntPropFloat(ent, Prop_Send, "m_flTotalTime");
        b stopWatchTimer      = view_as<b>(GetEntProp(     ent, Prop_Send, "m_bStopWatchTimer"));
        
        // Check if game is ongoing using m_bAwaitingReadyRestart and timer pause state
        b awaitingReadyRestart = view_as<b>(GameRules_GetProp("m_bAwaitingReadyRestart"));
        b gameOngoing = !awaitingReadyRestart && !timerPaused && !isDisabled;
        
        ReplyToCommand(client, "[timer %d] m_bTimerPaused=%d m_flTimeRemaining=%.2f m_flTimerEndTime=%.2f m_bIsDisabled=%d m_bShowInHUD=%d", ent, timerPaused, timeRemaining, timerEndTime, isDisabled, showInHUD);
        ReplyToCommand(client, "[timer %d] m_nTimerLength=%d m_nTimerInitialLength=%d m_nTimerMaxLength=%d m_bAutoCountdown=%d", ent, timerLength, timerInitialLength, timerMaxLength, autoCountdown);
        ReplyToCommand(client, "[timer %d] m_nSetupTimeLength=%d m_nState=%d m_bStartPaused=%d m_bShowTimeRemaining=%d", ent, setupTimeLength, state, startPaused, showTimeRemaining);
        ReplyToCommand(client, "[timer %d] m_bInCaptureWatchState=%d m_flTotalTime=%.2f m_bStopWatchTimer=%d", ent, inCaptureWatchState, totalTime, stopWatchTimer);
        ReplyToCommand(client, "[timer %d] Game Ongoing: %d (m_bAwaitingReadyRestart=%d)", ent, gameOngoing, awaitingReadyRestart);
        
        found++;
    }
    
    if (found == 0) return EndCmd(client, "No team_round_timer found.");
    PH;
}

// ====================================================================================================
// EMERGENCY TOURNAMENT ADMIN COMMANDS
// ====================================================================================================

// Emergency toggle for resupply functionality
NEW_CMD(CToggleResupply) {
    if (args != 1) return EndCmd(client, "Usage: sm_toggle_resupply <0|1>");
    
    c arg[4];
    GetCmdArg(1, arg, sizeof(arg));
    i value = StringToInt(arg);
    
    if (value != 0 && value != 1) return EndCmd(client, "Usage: sm_toggle_resupply <0|1> (0=disable, 1=enable)");
    
    g_bResupplyEnabled = (value != 0);
    
    // Reset failsafe when manually enabling
    if (g_bResupplyEnabled) {
        g_bFailsafeTriggered = false;
    }
    
    ReplyToCommand(client, "[EMERGENCY] Resupply functionality %s", g_bResupplyEnabled ? "ENABLED" : "DISABLED");
    LogAction(client, -1, "Admin %L %s resupply functionality", client, g_bResupplyEnabled ? "enabled" : "disabled");
    PH;
}

// Emergency toggle for instant respawn
NEW_CMD(CToggleRespawn) {
    if (args != 1) return EndCmd(client, "Usage: sm_toggle_respawn <0|1>");
    
    c arg[4];
    GetCmdArg(1, arg, sizeof(arg));
    i value = StringToInt(arg);
    
    if (value != 0 && value != 1) return EndCmd(client, "Usage: sm_toggle_respawn <0|1> (0=disable, 1=enable)");
    
    g_bInstantRespawnEnabled = (value != 0);
    
    ReplyToCommand(client, "[EMERGENCY] Instant respawn %s", g_bInstantRespawnEnabled ? "ENABLED" : "DISABLED");
    LogAction(client, -1, "Admin %L %s instant respawn", client, g_bInstantRespawnEnabled ? "enabled" : "disabled");
    PH;
}

// Emergency toggle for immunity and infinite ammo
NEW_CMD(CToggleImmunity) {
    if (args != 1) return EndCmd(client, "Usage: sm_toggle_immunity <0|1>");
    
    c arg[4];
    GetCmdArg(1, arg, sizeof(arg));
    i value = StringToInt(arg);
    
    if (value != 0 && value != 1) return EndCmd(client, "Usage: sm_toggle_immunity <0|1> (0=disable, 1=enable)");
    
    g_bImmunityAmmoEnabled = (value != 0);
    
    // If disabling, turn off immunity and infinite ammo for all players
    if (!g_bImmunityAmmoEnabled) {
        for (i n = 1; n <= MaxClients; n++) {
            if (IsClientInGame(n)) {
                g_bNoDamage[n] = false;
                g_bInfiniteAmmo[n] = false;
                if (g_hOriginalAmmo[n] != null) {
                    delete g_hOriginalAmmo[n];
                    g_hOriginalAmmo[n] = null;
                }
            }
        }
    }
    
    ReplyToCommand(client, "[EMERGENCY] Immunity and infinite ammo %s", g_bImmunityAmmoEnabled ? "ENABLED" : "DISABLED");
    LogAction(client, -1, "Admin %L %s immunity and infinite ammo", client, g_bImmunityAmmoEnabled ? "enabled" : "disabled");
    PH;
}

// Emergency toggle for save/load spawn functionality
NEW_CMD(CToggleSaveLoad) {
    if (args != 1) return EndCmd(client, "Usage: sm_toggle_saveload <0|1>");
    
    c arg[4];
    GetCmdArg(1, arg, sizeof(arg));
    i value = StringToInt(arg);
    
    if (value != 0 && value != 1) return EndCmd(client, "Usage: sm_toggle_saveload <0|1> (0=disable, 1=enable)");
    
    g_bSaveLoadEnabled = (value != 0);
    
    ReplyToCommand(client, "[EMERGENCY] Save/Load spawn functionality %s", g_bSaveLoadEnabled ? "ENABLED" : "DISABLED");
    LogAction(client, -1, "Admin %L %s save/load spawn functionality", client, g_bSaveLoadEnabled ? "enabled" : "disabled");
    PH;
}

// Show current plugin feature status
NEW_CMD(CPluginStatus) {
    ReplyToCommand(client, "[PLUGIN STATUS]");
    ReplyToCommand(client, "Resupply: %s%s", g_bResupplyEnabled ? "ENABLED" : "DISABLED", g_bFailsafeTriggered ? " (FAILSAFE TRIGGERED)" : "");
    ReplyToCommand(client, "Instant Respawn: %s", g_bInstantRespawnEnabled ? "ENABLED" : "DISABLED");
    ReplyToCommand(client, "Immunity/Infinite Ammo: %s", g_bImmunityAmmoEnabled ? "ENABLED" : "DISABLED");
    ReplyToCommand(client, "Save/Load Spawn: %s", g_bSaveLoadEnabled ? "ENABLED" : "DISABLED");
    ReplyToCommand(client, "Stalemate Fix: %s", g_bFixStalemateScoring ? "ENABLED" : "DISABLED");
    ReplyToCommand(client, "Overtime: %s", g_bDisableOvertime ? "DISABLED" : "ENABLED");
    ReplyToCommand(client, "Match Active: %s", IsMatchActive() ? "YES" : "NO");
    PH;
}

// Toggle stalemate scoring fix
NEW_CMD(CStalemateFix) {
    if (args != 1) return EndCmd(client, "Usage: sm_stalemate_fix <0|1> (0=disable fix, 1=enable fix)");
    
    c arg[4];
    GetCmdArg(1, arg, sizeof(arg));
    i value = StringToInt(arg);
    
    if (value < 0 || value > 1) return EndCmd(client, "Invalid value. Use 0 (disable) or 1 (enable).");
    
    g_bFixStalemateScoring = (value == 1);
    
    LogAction(client, -1, "Admin %L %s stalemate scoring fix", client, g_bFixStalemateScoring ? "enabled" : "disabled");
    ReplyToCommand(client, "Stalemate scoring fix %s.", g_bFixStalemateScoring ? "ENABLED" : "DISABLED");
    
    PH;
}

// Toggle overtime disable
NEW_CMD(CDisableOvertime) {
    if (args != 1) return EndCmd(client, "Usage: sm_disable_overtime <0|1> (0=enable overtime, 1=disable overtime)");
    
    c arg[4];
    GetCmdArg(1, arg, sizeof(arg));
    i value = StringToInt(arg);
    
    if (value < 0 || value > 1) return EndCmd(client, "Invalid value. Use 0 (enable overtime) or 1 (disable overtime).");
    
    g_bDisableOvertime = (value == 1);
    
    LogAction(client, -1, "Admin %L %s overtime", client, g_bDisableOvertime ? "disabled" : "enabled");
    ReplyToCommand(client, "Overtime %s.", g_bDisableOvertime ? "DISABLED" : "ENABLED");
    
    PH;
}

// Parse class from string
TFClassType ParseClass( c[] s ) {
    if ( StrEqual( s, "soldier" )  || StrEqual( s, "2" ) ) return TFClass_Soldier;
    if ( StrEqual( s, "demo" )     || StrEqual( s, "demoman" ) || StrEqual( s, "4" ) ) return TFClass_DemoMan;
    if ( StrEqual( s, "medic" )    || StrEqual( s, "7" ) ) return TFClass_Medic;
    return TFClass_Unknown;
}

// ====================================================================================================
// EVENTS
// ====================================================================================================

// Handle player death event
pub Act EPDeath( Ev event, const c[] name, b dontBroadcast ) {
    i userid = event.GetInt( "userid" );
    i client = GetClientOfUserId(userid);
    
    if (IsMatchActive()) PCO;
    
    // Validate client before proceeding
    if (client <= 0 || client > MaxClients || !IsClientInGame(client)) PCO;
    
    // Check if instant respawn is globally enabled
    if (g_bInstantRespawnEnabled && g_cvRespawnTime.FloatValue <= 0.0) {
        RequestFrame( Respawn_Frame, userid );
    }
    
    PCO;
}

// Player connect event - prepare for tracking
NEW_EV(EPConnect) {
    i client = GetClientOfUserId( event.GetInt( "userid" ) );

    if ( client > 0 && client <= MaxClients && g_bBackupFOVDB ) {
        // Reset tracking for this player slot if backup system is active
        g_bPlayerTracked[ client ] = false;
        g_iPlayerFOV[ client ]     = 0;
    }
}

// Player disconnect event - clean up tracking
NEW_EV(EPDisconnect) {
    i userid = event.GetInt( "userid" );
    i client = GetClientOfUserId( userid );

    if ( client > 0 && client <= MaxClients && g_bBackupFOVDB ) {
        // Clear tracking data for this slot if backup system is active
        g_bPlayerTracked[ client ] = false;
        g_iPlayerFOV[ client ]     = 0;
    }
}

// PASS Time score event - track scoring for stalemate fix
NEW_EV_ACT(EPPassScore) {
    PrintToChatAll("\x0799CCFF[DEBUG] \x01pass_score event fired");
    
    if (!g_bFixStalemateScoring) PCO;
    
    i scoringTeam = event.GetInt("team");
    i points = event.GetInt("points");
    
    // Get current round scores (these are the scores AFTER the goal)
    i redScore = GameRules_GetProp("m_iRoundScore", .element = 2);  // RED team
    i bluScore = GameRules_GetProp("m_iRoundScore", .element = 3);  // BLU team
    
    PrintToChatAll("\x0799CCFF[DEBUG] \x01Team %d scored %d points. Scores: RED=%d, BLU=%d", scoringTeam, points, redScore, bluScore);
    
    // Check if this score creates a tie (stalemate condition)
    // The scores should be equal AFTER scoring
    if (redScore == bluScore) {
        // Check if the main game timer has finished
        b timerFinished = IsMainTimerFinished();
        
        if (timerFinished) {
            g_bScoredIntoStalemate = true;
            PrintToChatAll("\x07FF6B6B[STALEMATE FIX] \x01Score tied %d-%d, timer finished - Game ending immediately (no ball respawn wait)", redScore, bluScore);
            
            // Force end the round immediately as a stalemate
            CreateTimer(0.1, Timer_ForceStalemate, 0, TIMER_FLAG_NO_MAPCHANGE);
        } else {
            PrintToChatAll("\x0799CCFF[STALEMATE] \x01Score tied %d-%d but timer active - Normal overtime rules", redScore, bluScore);
        }
    }
    
    PCO;
}

// Stalemate event - handle immediate end if we scored into stalemate
NEW_EV_ACT(EPStalemate) {
    PrintToChatAll("\x0799CCFF[STALEMATE] \x01Stalemate event triggered");
    
    if (!g_bFixStalemateScoring) {
        PrintToChatAll("\x0799CCFF[STALEMATE] \x01Fix disabled - Normal stalemate behavior");
        PCO;
    }
    
    if (g_bScoredIntoStalemate) {
        // Reset the flag
        g_bScoredIntoStalemate = false;
        
        // This stalemate was caused by scoring, so we want it to end immediately
        PrintToChatAll("\x07FF6B6B[STALEMATE FIX] \x01Scored into tie - Game ending immediately (no 30s wait)");
        LogMessage("Stalemate triggered by scoring - ending immediately");
    } else {
        PrintToChatAll("\x0799CCFF[STALEMATE] \x01Natural stalemate - Normal behavior");
    }
    
    PCO;
}

// Ball thrown/released event - NOT when it goes neutral
NEW_EV_ACT(EPPassFree) {
    PrintToChatAll("\x0799CCFF[STALEMATE] \x01Ball thrown/released (still team-owned)");
    
    // This event fires when ball is thrown but still team-owned
    // We need to start monitoring for when it actually goes neutral (hits ground)
    
    if (!g_bFixStalemateScoring) {
        PrintToChatAll("\x0799CCFF[STALEMATE] \x01Fix disabled, ignoring");
        PCO;
    }
    
    // Check if we're in overtime by looking at game state
    b timerFinished = IsMainTimerFinished();
    if (!g_bInOvertime && !timerFinished) {
        PrintToChatAll("\x0799CCFF[STALEMATE] \x01Not in overtime and timer active, ignoring");
        PCO;
    }
    
    // If timer is finished but we haven't detected overtime yet, assume we're in overtime
    if (timerFinished && !g_bInOvertime) {
        PrintToChatAll("\x0799CCFF[STALEMATE] \x01Timer finished - Assuming overtime mode");
        g_bInOvertime = true;
    }
    
    // Get current round scores
    i redScore = GameRules_GetProp("m_iRoundScore", .element = 2);
    i bluScore = GameRules_GetProp("m_iRoundScore", .element = 3);
    
    PrintToChatAll("\x0799CCFF[STALEMATE] \x01Overtime ball thrown - Scores: RED %d, BLU %d", redScore, bluScore);
    
    // Only care if scores are tied in overtime
    if (redScore == bluScore) {
        // Start monitoring ball state in OnGameFrame for real-time detection
        if (!g_bMonitorBallState) {
            g_bMonitorBallState = true;
            g_iLastBallTeam = -1;
            PrintToChatAll("\x0799CCFF[STALEMATE] \x01Started real-time ball monitoring (tied overtime)");
        }
    } else {
        PrintToChatAll("\x0799CCFF[STALEMATE] \x01Scores not tied, no monitoring needed");
    }
    
    PCO;
}

// Ball picked up event - reset neutral timer
NEW_EV_ACT(EPPassGet) {
    PrintToChatAll("\x0799CCFF[STALEMATE] \x01Ball picked up by player");
    
    if (!g_bFixStalemateScoring) {
        PCO;
    }
    
    if (!g_bInOvertime) {
        PCO;
    }
    
    // Reset the neutral timer when ball is picked up
    if (g_fBallNeutralStartTime > 0.0) {
        f neutralTime = GetGameTime() - g_fBallNeutralStartTime;
        PrintToChatAll("\x0799CCFF[STALEMATE] \x01Ball neutral timer reset (was %.1fs)", neutralTime);
        g_fBallNeutralStartTime = 0.0;
    }
    
    PCO;
}

// Overtime begin event - prevent overtime if disabled
NEW_EV_ACT(EPOvertimeBegin) {
    g_bInOvertime = true;
    
    if (g_bDisableOvertime) {
        PrintToChatAll("\x07FF6B6B[OVERTIME DISABLED] \x01Overtime disabled by admin - Game ending immediately");
        
        // Force end the round as a stalemate
        CreateTimer(0.1, Timer_ForceStalemate, 0, TIMER_FLAG_NO_MAPCHANGE);
        
        PH; // Block the overtime from starting
    }
    
    PrintToChatAll("\x0799CCFF[STALEMATE] \x01Overtime started - Real-time ball monitoring active");
    PCO;
}

// Overtime end event - cleanup
NEW_EV_ACT(EPOvertimeEnd) {
    PrintToChatAll("\x0799CCFF[STALEMATE] \x01Overtime ended - Stopping ball monitoring");
    g_bInOvertime = false;
    
    // Stop ball monitoring
    g_bMonitorBallState = false;
    g_fBallNeutralStartTime = 0.0;
    g_iLastBallTeam = -1;
    
    LogMessage("Overtime ended");
    PCO;
}

// Check if the main game timer has finished
b IsMainTimerFinished() {
    i timerEnt = -1;
    
    // Find any active team_round_timer entity
    while ((timerEnt = FindEntityByClassname(timerEnt, "team_round_timer")) != -1) {
        b timerPaused = view_as<b>(GetEntProp(timerEnt, Prop_Send, "m_bTimerPaused"));
        b timerDisabled = view_as<b>(GetEntProp(timerEnt, Prop_Send, "m_bIsDisabled"));
        f timeRemaining = GetEntPropFloat(timerEnt, Prop_Send, "m_flTimeRemaining");
        
        // Timer is finished if time remaining is 0 or very close to 0
        // and the timer is not disabled
        if (!timerDisabled && timeRemaining <= 0.1) {
            return true;
        }
        
        // If we found a timer that's still running, return false
        if (!timerDisabled && !timerPaused && timeRemaining > 0.1) {
            return false;
        }
    }
    
    // If no active timer found, assume timer has finished
    return true;
}



// Function to check ball neutral state in real-time
v CheckBallNeutralState() {
    // Get current round scores to ensure they're still tied
    i redScore = GameRules_GetProp("m_iRoundScore", .element = 2);
    i bluScore = GameRules_GetProp("m_iRoundScore", .element = 3);
    
    // Stop monitoring if scores are no longer tied
    if (redScore != bluScore) {
        g_bMonitorBallState = false;
        g_fBallNeutralStartTime = 0.0;
        g_iLastBallTeam = -1;
        PrintToChatAll("\x0799CCFF[STALEMATE] \x01Scores no longer tied - Stopped ball monitoring");
        return;
    }
    
    // Try to find the ball entity
    i ballEntity = FindEntityByClassname(-1, "passtime_ball");
    if (ballEntity == -1) {
        // No ball found, might be respawning - keep monitoring
        return;
    }
    
    // Check current ball team (0 = neutral)
    i ballTeam = GetEntProp(ballEntity, Prop_Send, "m_iTeam");
    
    // Ball is neutral if team is 0
    b ballIsNeutral = (ballTeam == 0);
    
    // Only show debug when team changes
    if (g_iLastBallTeam != ballTeam) {
        PrintToChatAll("\x0799CCFF[STALEMATE] \x01Ball team changed: %d -> %d (neutral=%s)", 
                      g_iLastBallTeam, ballTeam, ballIsNeutral ? "true" : "false");
    }
    
    if (ballIsNeutral) {
        f currentTime = GetGameTime();
        
        if (g_fBallNeutralStartTime == 0.0) {
            // Ball just went neutral
            g_fBallNeutralStartTime = currentTime;
            PrintToChatAll("\x07FF6B6B[STALEMATE FIX] \x01Ball went neutral in tied overtime (team=%d)", ballTeam);
        } else {
            // Ball has been neutral - check if we should show progress
            f neutralTime = currentTime - g_fBallNeutralStartTime;
            
            // Show progress every 3 seconds
            static f lastProgressTime = 0.0;
            if (currentTime - lastProgressTime >= 3.0) {
                PrintToChatAll("\x0799CCFF[STALEMATE] \x01Ball neutral: %.1f/15.0 seconds", neutralTime);
                lastProgressTime = currentTime;
            }
            
            // Force stalemate after 15 seconds
            if (neutralTime >= 15.0) {
                PrintToChatAll("\x07FF6B6B[STALEMATE FIX] \x01Ball neutral 15+ seconds in tied overtime - Game ending immediately!");
                
                // Stop monitoring and force stalemate
                g_bMonitorBallState = false;
                g_fBallNeutralStartTime = 0.0;
                CreateTimer(0.1, Timer_ForceStalemate, 0, TIMER_FLAG_NO_MAPCHANGE);
                return;
            }
        }
    } else {
        // Ball is not neutral - reset timer if it was running
        if (g_fBallNeutralStartTime > 0.0) {
            PrintToChatAll("\x0799CCFF[STALEMATE] \x01Ball no longer neutral (team=%d) - Timer reset", ballTeam);
            g_fBallNeutralStartTime = 0.0;
        }
    }
    
    // Update last known state
    g_iLastBallTeam = ballTeam;
}

// Timer callback to force stalemate end
pub Act Timer_ForceStalemate(Han timer, any data) {
    // Force the round to end as a stalemate
    i entity = CreateEntityByName("game_round_win");
    if (entity != -1) {
        DispatchKeyValue(entity, "force_map_reset", "1");
        DispatchKeyValue(entity, "winner", "0"); // 0 = stalemate
        DispatchSpawn(entity);
        AcceptEntityInput(entity, "RoundWin");
        RemoveEntity(entity);
    }
    
    return Plugin_Stop;
}

// Restores the client's FOV, infinite ammo, and immunity settings on spawn
NEW_EV(EPSpawn) {
    i client = GetClientOfUserId( event.GetInt( "userid" ) );
    if ( !IsValidClient( client ) ) return;

    // Try to restore settings from cookies first
    if ( AreClientCookiesCached( client ) ) {
        if ( RestoreFOV( client ) ) {
            // If we were using backup but Steam is now connected, we can disable it
            if ( !g_bSteamConnected ) {
                g_bSteamConnected = true;
                if ( g_bBackupFOVDB ) SetBackupSystem( false );
            }
        }
        
        // Restore infinite ammo and immunity settings
        RestoreInfiniteAmmoSetting( client );
        RestoreImmunitySetting( client );
        return;
    } else if ( !g_bBackupFOVDB ) {
        // Steam is down, initialize backup system
        SetBackupSystem( true );
        g_bSteamConnected = false;
    }

    // If cookies failed or aren't cached, try backup system
    if ( g_bBackupFOVDB && g_bPlayerTracked[ client ] && g_iPlayerFOV[ client ] > 0 ) {
        SetFOV( client, g_iPlayerFOV[ client ] );
    }
    
    // Restore from backup system for infinite ammo and immunity
    if ( g_bBackupInfiniteAmmoTracked[ client ] ) {
        g_bInfiniteAmmo[ client ] = g_bBackupInfiniteAmmo[ client ];
        if ( g_bInfiniteAmmo[ client ] ) {
            StoreOriginalAmmo( client );
        }
    }
    
    if ( g_bBackupImmunityTracked[ client ] ) {
        g_bNoDamage[ client ] = g_bBackupImmunity[ client ];
    }
}

// Retrieves the client's FOV from their local config and stores it in a cookie
pub OnFOVQueried( QueryCookie cookie, i client, ConVarQueryResult result, const c[] cvarName, const c[] fov ) {
    if ( result != ConVarQuery_Okay ) return;
    SetClientCookie( client, g_hCookieFOV, "" );
    SetFOV(          client, StringToInt( fov ) );
}

// ====================================================================================================
// HELPERS
// ====================================================================================================

// Sends a message to the client and returns PH
Act EndCmd( i client, const c[] format, any... ) {
    c buffer[ 254 ];
    VFormat( buffer, sizeof( buffer ), format, 3 );
    ReplyToCommand( client, "%s", buffer );
    PH;
}   

// Checks if a client in-game, connected, not fake, alive and in a valid team
b IsValidClient( i client ) {
    return client > 0 && client <= MaxClients && IsClientInGame( client ) && !IsFakeClient( client ) && IsPlayerAlive( client ) && IsClientConnected( client );
}

// Sets the client's FOV
SetFOV( i client, i fov ) {
    SetEntProp( client, Prop_Send, "m_iFOV",        fov );
    SetEntProp( client, Prop_Send, "m_iDefaultFOV", fov );
}

// Retrieves the client's FOV from the cookie and applies it, returns false if invalid
b RestoreFOV( i client ) {
    c cookie[ 4 ];
    GetClientCookie( client, g_hCookieFOV, cookie, sizeof( cookie ) );
    i fov = StringToInt( cookie ),
      min = GetConVarInt( g_cvFOVMin ),
      max = GetConVarInt( g_cvFOVMax );

    if ( fov < min || fov > max ) return false;

    // If backup system is active, update it with cookie value
    if ( g_bBackupFOVDB ) {
         g_iPlayerFOV[ client ]     = fov;
         g_bPlayerTracked[ client ] = true;
    }

    SetFOV( client, fov );
    return true;
}

// Parse TFTeam from string
TFTeam ParseTeam( c[] t ) {
    return StrEqual( t, "spectator" ) || StrEqual( t, "spec" ) || StrEqual( t, "s" ) ? TFTeam_Spectator
         : StrEqual( t, "red" )       || StrEqual( t, "r" )                          ? TFTeam_Red
         : StrEqual( t, "blue" )      || StrEqual( t, "blu" )  || StrEqual( t, "b" ) ? TFTeam_Blue
                                                                                     : TFTeam_Unassigned;
}

// Converts team name string to RED/BLU constants
i ParseTeamIndex( c[] t ) {
    return StrEqual( t, "red" ) || StrEqual( t, "r" )                          ? RED
         : StrEqual( t, "blu" ) || StrEqual( t, "blue" ) || StrEqual( t, "b" ) ? BLU
                                                                               : -1;
}

// Enable or disable the backup system based on Steam connection status
SetBackupSystem( b a ) {
    if ( g_bBackupFOVDB == a ) return;    // Already in desired state
    g_bBackupFOVDB = a;
    // Initialize/clear player tracking arrays
    for ( i n = 0; n <= MaxClients; n++ ) {
        g_iPlayerFOV[ n ]     = 0;
        g_bPlayerTracked[ n ] = false;
        g_bBackupInfiniteAmmoTracked[ n ] = false;
        g_bBackupImmunityTracked[ n ] = false;
        g_bBackupInfiniteAmmo[ n ] = false;
        g_bBackupImmunity[ n ] = false;
    }

    if ( a ) PrintToServer( "Backup system enabled - Steam connection is down" );
    else PrintToServer(     "Backup system disabled - Steam connection restored" );
}

// Respawn frame callback
pub v Respawn_Frame( any userid ) {
    // Get client from userid and validate
    i client = GetClientOfUserId( userid );
    
    
    // Validate client is connected and in-game
    if (client <= 0 || client > MaxClients || !IsClientInGame(client)) return;
    
    // Only respawn if on a team and not alive
    if (GetClientTeam(client) > 1 && !IsPlayerAlive(client)) TF2_RespawnPlayer(client);
}

// Command for when resupply key is pressed
NEW_CMD(CResupplyDn) {
    // Check if resupply is globally enabled
    if (!g_bResupplyEnabled) return EndCmd(client, "Resupply functionality has been disabled by an administrator.");
    
    // Check if client is valid
    if (!IsClientInGame(client)) return EndCmd(client, "You must be in-game to use this command.");
    
    // Mark the key as down and reset used flag
    g_bResupplyDn[client] = true;
    g_bResupplyUp[client] = false;
    
    // Try to resupply immediately if in spawn room
    TryResupplyPlayer(client);
    
    PH;
}

// Command for when resupply key is released
NEW_CMD(CResupplyUp) {
    // Check if resupply is globally enabled
    if (!g_bResupplyEnabled) return EndCmd(client, "Resupply functionality has been disabled by an administrator.");
    
    // Check if client is valid
    if (!IsClientInGame(client)) return EndCmd(client, "You must be in-game to use this command.");
    
    // Mark the key as up
    g_bResupplyDn[client] = false;
    
    PH;
}

// Try to resupply a player if conditions are met
v TryResupplyPlayer(i client) {
    // Check if resupply is globally enabled
    if (!g_bResupplyEnabled) return;
    
    // Check if key is down and resupply hasn't been used yet
    if (!g_bResupplyDn[client] || g_bResupplyUp[client]) return;
    if (!IsPlayerAlive(client)) return;
    
    i playerTeam = GetClientTeam(client);
    if (playerTeam <= 1) return;
    
    if (!IsClientInSpawn(client)) return;
    
    // FAILSAFE: Check distance from nearest spawn point
    if (!g_bFailsafeTriggered && !CheckResupplyFailsafe(client)) {
        return; // Failsafe triggered, resupply blocked
    }
    
    TF2_RespawnPlayer(client);
    
    // Reset player velocity to zero
    f zeroVelocity[3] = {0.0, 0.0, 0.0};
    TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, zeroVelocity);
    
    g_bResupplyUp[client] = true;
}
// Check if a player is in their own spawnroom
b IsClientInSpawn(i client) {
    if (!IsValidClient(client)) return false;
    
    // Use our new reliable spawn room detection instead of the buggy native property
    return IsPlayerTouchingSpawnRoom(client);
}

// Check if a player is within the bounds of a brush entity
b IsPlayerInEntityBounds(i client, i entity) {
    if (!IsValidClient(client) || !IsValidEntity(entity)) return false;
    
    // Get player hull
    f playerMins[3], playerMaxs[3];
    GetClientMins(client, playerMins);
    GetClientMaxs(client, playerMaxs);
    
    // Get player position
    f playerPos[3];
    GetClientAbsOrigin(client, playerPos);
    
    // Calculate player hull bounds in world space
    f playerHullMins[3], playerHullMaxs[3];
    playerHullMins[0] = playerPos[0] + playerMins[0];
    playerHullMins[1] = playerPos[1] + playerMins[1];
    playerHullMins[2] = playerPos[2] + playerMins[2];
    playerHullMaxs[0] = playerPos[0] + playerMaxs[0];
    playerHullMaxs[1] = playerPos[1] + playerMaxs[1];
    playerHullMaxs[2] = playerPos[2] + playerMaxs[2];
    
    // Get entity bounds
    f entityMins[3], entityMaxs[3];
    GetEntPropVector(entity, Prop_Send, "m_vecMins", entityMins);
    GetEntPropVector(entity, Prop_Send, "m_vecMaxs", entityMaxs);
    
    // Check if player hull intersects with entity bounds
    return (playerHullMaxs[0] >= entityMins[0] && playerHullMins[0] <= entityMaxs[0] &&
            playerHullMaxs[1] >= entityMins[1] && playerHullMins[1] <= entityMaxs[1] &&
            playerHullMaxs[2] >= entityMins[2] && playerHullMins[2] <= entityMaxs[2]);
}

// Check if a player is touching any func_respawnroom entities of their own team
b IsPlayerTouchingSpawnRoom(i client) {
    if (!IsValidClient(client)) return false;
    
    i playerTeam = GetClientTeam(client);
    if (playerTeam <= 1) return false; // Spectator or unassigned
    
    // Reset player spawn room tracking
    g_bIsClientInSpawn[client] = false;
    for (i s = 0; s < MAX_SPAWN_ROOMS; s++) {
        g_iPlayerSpawns[client][s] = -1;
    }
    
    // Find all func_respawnroom entities
    i entity = -1;
    i spawnCount = 0;
    while ((entity = FindEntityByClassname(entity, "func_respawnroom")) != -1) {
        if (IsValidEntity(entity)) {
            // Check if this spawn room belongs to the player's team
            i spawnTeam = GetEntProp(entity, Prop_Send, "m_iTeamNum");
            if (spawnTeam == playerTeam) {
                // Check if player is within this entity's bounds
                if (IsPlayerInEntityBounds(client, entity)) {
                    g_bIsClientInSpawn[client] = true;
                    g_iPlayerSpawns[client][spawnCount] = entity;
                    spawnCount++;
                    
                    // Break if we've reached the maximum number of spawn rooms
                    if (spawnCount >= MAX_SPAWN_ROOMS) break;
                }
            }
        }
    }
    
    return g_bIsClientInSpawn[client];
}

// Get distance to nearest spawn point of player's team
f GetDistanceToNearestSpawn(i client) {
    if (!IsValidClient(client)) return 999999.0;
    
    i playerTeam = GetClientTeam(client);
    f playerPos[3];
    GetClientAbsOrigin(client, playerPos);
    
    f nearestDistance = 999999.0;
    
    // Find all info_player_teamspawn entities for the player's team
    i entity = -1;
    while ((entity = FindEntityByClassname(entity, "info_player_teamspawn")) != -1) {
        if (IsValidEntity(entity)) {
            i spawnTeam = GetEntProp(entity, Prop_Send, "m_iTeamNum");
            if (spawnTeam == playerTeam) {
                f spawnPos[3];
                GetEntPropVector(entity, Prop_Send, "m_vecOrigin", spawnPos);
                f distance = GetVectorDistance(playerPos, spawnPos);
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                }
            }
        }
    }
    
    return nearestDistance;
}

// Check resupply failsafe - returns false if failsafe triggers
b CheckResupplyFailsafe(i client) {
    f distanceToSpawn = GetDistanceToNearestSpawn(client);
    
    // If player is too far from nearest spawn point, trigger failsafe
    if (distanceToSpawn > FAILSAFE_DISTANCE) {
        g_bFailsafeTriggered = true;
        g_bResupplyEnabled = false;
        
        // Get player name for the message
        c playerName[MAX_NAME_LENGTH];
        GetClientName(client, playerName, sizeof(playerName));
        
        // Notify all players
        PrintToChatAll("\x07FF4500[FAILSAFE] \x01Resupply exploit detected! Player %s was %.1f units from spawn (max: %.1f)", playerName, distanceToSpawn, FAILSAFE_DISTANCE);
        PrintToChatAll("\x07FF4500[FAILSAFE] \x01Instant resupply has been automatically disabled.");
        PrintToChatAll("\x07FF4500[FAILSAFE] \x01Admins can re-enable with: \x07FFFF00sm_enable_resupply 1");
        
        // Log the event
        LogMessage("Resupply failsafe triggered by %L - distance %.1f > %.1f", client, distanceToSpawn, FAILSAFE_DISTANCE);
        
        return false;
    }
    
    return true;
}

// Called when a client disconnects
pub OnClientDisconnect(i client) {
    // Reset spawn room tracking
    g_bIsClientInSpawn[client]  = false;
    g_bResupplyDn[client]  = false;
    g_bResupplyUp[client]     = false;
    g_bNoDamage[client]         = false;
    g_bPendingRestoreHP[client] = false;
    g_iPreDamageHP[client]      = 0;
    g_bInfiniteAmmo[client]     = false;
    
    // Reset backup tracking for infinite ammo and immunity
    g_bBackupInfiniteAmmoTracked[client] = false;
    g_bBackupImmunityTracked[client] = false;
    g_bBackupInfiniteAmmo[client] = false;
    g_bBackupImmunity[client] = false;
    
    // Clean up infinite ammo ArrayList if it exists
    if (g_hOriginalAmmo[client] != null) {
        delete g_hOriginalAmmo[client];
        g_hOriginalAmmo[client] = null;
    }
    
    // Clear spawn room entity tracking
    for (i n = 0; n < MAX_SPAWN_ROOMS; n++) {
        g_iPlayerSpawns[client][n] = -1;
    }
}


// ====================================================================================================
// FORWARDS
// ====================================================================================================

// Called when a client's cookies have been loaded
pub v OnClientCookiesCached( i client ) {
    // Steam connection is now available
    g_bSteamConnected = true;

    // If we were using backup system but Steam is now connected, we can disable it
    if ( g_bBackupFOVDB ) SetBackupSystem( false );

    // Try to load from cookies
    RestoreFOV( client );
    RestoreInfiniteAmmoSetting( client );
    RestoreImmunitySetting( client );
}

// Save infinite ammo setting to cookies
v SaveInfiniteAmmoSetting(i client, b enabled) {
    if (AreClientCookiesCached(client)) {
        c cookie[2];
        IntToString(enabled ? 1 : 0, cookie, sizeof(cookie));
        SetClientCookie(client, g_hCookieInfiniteAmmo, cookie);
        g_bSteamConnected = true;
        
        // If we were using backup system but Steam is now connected, we can disable it
        if (g_bBackupFOVDB) SetBackupSystem(false);
    } else {
        // Steam is down, use backup system
        if (!g_bBackupFOVDB) SetBackupSystem(true);
        g_bSteamConnected = false;
        
        // Store in backup system
        g_bBackupInfiniteAmmo[client] = enabled;
        g_bBackupInfiniteAmmoTracked[client] = true;
    }
}

// Save immunity setting to cookies
v SaveImmunitySetting(i client, b enabled) {
    if (AreClientCookiesCached(client)) {
        c cookie[2];
        IntToString(enabled ? 1 : 0, cookie, sizeof(cookie));
        SetClientCookie(client, g_hCookieImmunity, cookie);
        g_bSteamConnected = true;
        
        // If we were using backup system but Steam is now connected, we can disable it
        if (g_bBackupFOVDB) SetBackupSystem(false);
    } else {
        // Steam is down, use backup system
        if (!g_bBackupFOVDB) SetBackupSystem(true);
        g_bSteamConnected = false;
        
        // Store in backup system
        g_bBackupImmunity[client] = enabled;
        g_bBackupImmunityTracked[client] = true;
    }
}

// Restore infinite ammo setting from cookies
b RestoreInfiniteAmmoSetting(i client) {
    c cookie[2];
    GetClientCookie(client, g_hCookieInfiniteAmmo, cookie, sizeof(cookie));
    
    if (strlen(cookie) == 0) return false; // No saved setting
    
    b enabled = (StringToInt(cookie) != 0);
    g_bInfiniteAmmo[client] = enabled;
    
    // If backup system is active, update it with cookie value
    if (g_bBackupFOVDB) {
        g_bBackupInfiniteAmmo[client] = enabled;
        g_bBackupInfiniteAmmoTracked[client] = true;
    }
    
    // Store original ammo if enabling
    if (enabled && IsValidClient(client)) {
        StoreOriginalAmmo(client);
    }
    
    return true;
}

// Restore immunity setting from cookies
b RestoreImmunitySetting(i client) {
    c cookie[2];
    GetClientCookie(client, g_hCookieImmunity, cookie, sizeof(cookie));
    
    if (strlen(cookie) == 0) return false; // No saved setting
    
    b enabled = (StringToInt(cookie) != 0);
    g_bNoDamage[client] = enabled;
    
    // If backup system is active, update it with cookie value
    if (g_bBackupFOVDB) {
        g_bBackupImmunity[client] = enabled;
        g_bBackupImmunityTracked[client] = true;
    }
    
    return true;
}

// Store original ammo values for a client
pub v StoreOriginalAmmo( i client ) {
    // Clean up existing ArrayList if it exists
    if (g_hOriginalAmmo[client] != null) {
        delete g_hOriginalAmmo[client];
    }
    
    // Create new ArrayList for this player
    g_hOriginalAmmo[client] = new ArrayList(34); // 2 clip values + 32 ammo types
    
    // Get the active weapon
    i weapon = GetEntPropEnt( client, Prop_Send, "m_hActiveWeapon" );
    if ( weapon == -1 || !IsValidEntity( weapon ) ) return;
    
    // Store clip values
    g_hOriginalAmmo[client].Set(0, GetEntProp( weapon, Prop_Send, "m_iClip1" ));
    g_hOriginalAmmo[client].Set(1, GetEntProp( weapon, Prop_Send, "m_iClip2" ));
    
    // Store reserve ammo values for all ammo types
    for ( i ammoType = 0; ammoType < 32; ammoType++ ) {
        g_hOriginalAmmo[client].Set(ammoType + 2, GetEntProp( client, Prop_Send, "m_iAmmo", _, ammoType ));
    }
}

// Restore original ammo values for a client
pub v RestoreOriginalAmmo( i client ) {
    // Check if player has stored ammo data
    if (g_hOriginalAmmo[client] == null) return;
    
    // Get the active weapon
    i weapon = GetEntPropEnt( client, Prop_Send, "m_hActiveWeapon" );
    if ( weapon == -1 || !IsValidEntity( weapon ) ) return;
    
    // Restore clip values
    SetEntProp( weapon, Prop_Send, "m_iClip1", g_hOriginalAmmo[client].Get(0) );
    SetEntProp( weapon, Prop_Send, "m_iClip2", g_hOriginalAmmo[client].Get(1) );
    
    // Restore reserve ammo values
    for ( i ammoType = 0; ammoType < 32; ammoType++ ) {
        SetEntProp( client, Prop_Send, "m_iAmmo", g_hOriginalAmmo[client].Get(ammoType + 2), _, ammoType );
    }
}

// SDKHooks damage filter: prevent/zero damage if victim is protected or attacker is restricted
pub Act Hook_OnTakeDamage( i victim, i &attacker, i &inflictor, f &damage, i &damagetype, i &weapon, f damageForce[3], f damagePosition[3], i damagecustom ) {
    if (IsMatchActive()) PCO;
    
    // If the victim is invulnerable: allow knockback by letting damage go through, but prevent death and restore HP afterward
    if ( victim >= 1 && victim <= MaxClients && g_bNoDamage[ victim ] ) {
        // Store current health for restoration
        g_iPreDamageHP[ victim ] = GetClientHealth( victim );
        g_bPendingRestoreHP[ victim ] = true;
        
        // Allow damage to go through for knockback calculation
        // We'll restore health in the post-damage hook
        
        // If player has very low health, ensure they don't die
        if ( g_iPreDamageHP[ victim ] <= 1 ) {
            // For extremely low health, we still need minimal damage for knockback
            damage = 1.0;
        }
        PCH;
    }
    // If the attacker is invulnerable: their hits do no damage
    if ( attacker >= 1 && attacker <= MaxClients && g_bNoDamage[ attacker ] ) {
        if ( damage > 0.0 ) damage = 0.0;
        PCH;
    }
    PCO;
}

// Post-damage hook (reserved for future use, e.g., preserving knockback if needed)
pub v Hook_OnTakeDamagePost( i victim, i attacker, i inflictor, f damage, i damagetype, i weapon, f damageForce[3], f damagePosition[3], i damagecustom ) {
    if (IsMatchActive()) return;
    
    if ( victim >= 1 && victim <= MaxClients && g_bPendingRestoreHP[ victim ] ) {
        g_bPendingRestoreHP[ victim ] = false;
        if ( IsClientInGame( victim ) && IsPlayerAlive( victim ) ) {
            // Restore health to pre-damage value
            SetEntProp( victim, Prop_Send, "m_iHealth", g_iPreDamageHP[ victim ] );
        }
    }
}